<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from janus.conf.meetecho.com/docs/rest.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 25 Jul 2014 16:30:37 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>RESTful and WebSockets API</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="css/bootstrap.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 1001;" src="../../s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<nav class="navbar navbar-default navbar-static-top">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href=".html">Janus</a>
		<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
	</div>
	<div class="navbar-collapse collapse">
		<ul class="nav navbar-nav">
			<li><a href="../index-2.html">Home</a></li>
			<li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Demos <b class="caret"></b></a>
				<ul class="dropdown-menu">
					<li><a href="../demos.html">Index</a></li>
					<li class="divider"></li>
					<li><a href="../echotest.html">Echo Test</a></li>
					<li><a href="../streamingtest.html">Streaming</a></li>
					<li><a href="../videocalltest.html">Video Call</a></li>
					<li><a href="../siptest.html">SIP Gateway</a></li>
					<li><a href="../videomcutest.html">Video MCU</a></li>
					<li><a href="../audiobridgetest.html">Audio Conference</a></li>
					<li><a href="../voicemailtest.html">Voice Mail</a></li>
					<li><a href="../screensharingtest.html">Screen Sharing</a></li>
				</ul>
			</li>
			<li class="active"><a href="index-2.html">Documentation</a></li>
		</ul>
		<div class="navbar-header navbar-right">
			<ul id="topmenu" class="nav navbar-nav">
<!--
				<li>
					<form class="navbar-form navbar-left" role="search">
						<div class="form-group">
							<input type="text" class="form-control" placeholder="Search"/>
						</div>
					</form>
				</li>
-->
				<li><a href="http://groups.google.com/d/forum/meetecho-janus" class="navbar-link"><b>Discuss Janus</b></a></li>
				<li><a href="http://www.meetecho.com/" class="navbar-link"><img src="meetecho-logo-white.png"/> <b>Meetecho</b></a></li>
			</ul>
		</div>
	</div>
</div>
</nav>
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index-2.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RESTful and WebSockets API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Since version <code>0.0.4</code>, there are two different ways to interact with a Janus instance: a <a class="el" href="rest.html#plainhttp">Plain HTTP REST Interface</a> (the default) and a <a class="el" href="rest.html#WS">WebSockets Interface</a> (optional, needs an external library to be available). Both the interfaces use the same messages (in terms of requests, responses and notifications), so almost all the concepts described in the <a class="el" href="rest.html#plainhttp">Plain HTTP REST Interface</a> section apply to the WebSocket interface as well. As it will be explained later in the <a class="el" href="rest.html#WS">WebSockets Interface</a> section below, the only differences come when addressing specific sessions/handles and in part in how you handle notifications using WebSockets: in fact, since with WebSockets there's no REST-based path involved, you'll need a couple of additional identifiers to bridge the gap.</p>
<h1><a class="anchor" id="plainhttp"></a>
Plain HTTP REST Interface</h1>
<p>As anticipated in the <a class="el" href="JS.html">JavaScript API</a> documentation, the gateway deploys a RESTful interface that clients can exploit. The <code>janus.js</code> library makes use of it in a transparent way, but if you're interested in more details about it (e.g., because you want to talk to the gateway your own way), this page described the interface and the protocol the API exposes and uses. Some details are also provided in case you're interested in <a class="el" href="rest.html#secret">Securing the API</a> when wrapping requests in your application.</p>
<p>There are basically three types/levels of endpoints you can meet:</p>
<ol type="1">
<li><a class="el" href="rest.html#root">The gateway root</a> (<code>/janus</code> by default, but configurable), which you only <b>POST</b> to in order to create a gateway session;</li>
<li><a class="el" href="rest.html#sessions">The session endpoint</a> (e.g., <code>/janus/12345678</code>, using the identifier retrieved with a previous create), which you either send a <b>GET</b> to (long poll for events and messages from plugins) or a <b>POST</b> (to create plugin handles or manipulate the session);</li>
<li><a class="el" href="rest.html#handles">The plugin handle endpoint</a> (e.g., <code>/janus/12345678/98765432</code>, appending the handle identifier to the session one) which you only send <b>POST</b> messages to (messages/negotiations for a plugin, handle manipulation), as all events related to this handle would be received in the session endpoint <b>GET</b> (the <code>janus.js</code> library would redirect the incoming messages to the right handle internally).</li>
</ol>
<p>Messages and requests you can send to and receive from any of the above mentioned endpoints are described in the following chapters. In general, all messages share at least two fields:</p>
<ul>
<li><code>janus:</code> the request/event (e.g., "create", "attach", "message", etc.);</li>
<li><code>transaction:</code> a random string that the client can use to match incoming messages from the gateway (since, as explained in the <a class="el" href="group__plugins.html">Plugins</a> documentation, all messages are asynchronous).</li>
</ul>
<p>Different messages will of course add different information to this base syntax. Error message, instead, usually have these fields:</p>
<ul>
<li><code>janus:</code> this would be "error";</li>
<li><code>transaction:</code> this would be the transaction identifier of the request that failed;</li>
<li><code>error:</code> a JSON object containing two fields:<ul>
<li><code>code:</code> a numeric error code, as defined in <a class="el" href="apierror_8h.html" title="Janus API errors definition.">apierror.h</a>;</li>
<li><code>reason:</code> a verbose string describing the cause of the failure.</li>
</ul>
</li>
</ul>
<p>An example of an error is presented here:</p>
<pre class="fragment">{
        "janus" : "error",
        "transaction" : "a1b2c3d4"
        "error" : {
                "code" : 458
                "reason" : "Could not find session 12345678"
        }
}
</pre><h1><a class="anchor" id="info"></a>
Getting info about the Janus instance</h1>
<p>The API exposes an <code>info</code> endpoint you can query to get information about the Janus instance you're talking to. Specifically, it returns information about the version of the Janus server, whether some of the optional features (Data Channels and WebSockets) are supported or not, and which plugins are available.</p>
<p>To get this information, just send an HTTP <b>GET</b> message to the <code>info</code> endpoint (e.g., <a href="http://yourserver:8088/janus/info">http://yourserver:8088/janus/info</a>), which will return something like this:</p>
<pre class="fragment">{
        "version_string": "0.0.4",
        "author": "Meetecho s.r.l.",
        "name": "Janus WebRTC Gateway",
        "version": 4,
        "websockets": 1,                // WebSockets are supported
        "data_channels": 1,             // Data Channels are supported
        "plugins": {
                "janus.plugin.sip": {           // The SIP plugin is available
                        "version_string": "0.0.2",
                        "description": "This is a simple SIP plugin for Janus, allowing WebRTC peers to register at a SIP server and call SIP user agents through the gateway.",
                        "author": "Meetecho s.r.l.",
                        "name": "JANUS SIP plugin",
                        "version": 2
                },
                "janus.plugin.videoroom": {     // The Video MCU plugin is available
                        "version_string": "0.0.3",
                        "description": "This is a plugin implementing a videoconferencing MCU for Janus, something like Licode.",
                        "author": "Meetecho s.r.l.",
                        "name": "JANUS VideoRoom plugin",
                        "version": 3
                },
                [..]    // Other plugins
        }
</pre><p>You can use this information to selectively enable or disable features in your application according to what's available in the Janus instance you're trying to contact.</p>
<h1><a class="anchor" id="root"></a>
The gateway root</h1>
<p>The gateway root is <code>/janus</code> by default but, as anticipated, it is configurable, either via command line or in the <code>janus.cfg</code> configuration.</p>
<p>You can only contact the gateway root when you want to create a new session with the gateway. To do so, you need to <b>POST</b> the a <code>janus</code> "create" JSON message to the gateway:</p>
<pre class="fragment">{
        "janus" : "create",
        "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><p>If the request is successful, you'll receive the unique session identifier in a response formatted like this:</p>
<pre class="fragment">{
        "janus" : "success",
        "transaction" : "&lt;same as the request&gt;"
        "data" : {
                "id" : &lt;unique integer session ID&gt;
        }
}
</pre><p>In case of an error, you'll receive an error message as the one introduced before. This request, if issued with a POST to the gateway root, can only fail if you miss any of the required fields in the request.</p>
<h1><a class="anchor" id="sessions"></a>
The session endpoint</h1>
<p>Once you've created a session, a new endpoint you can use is created in the gateway. Specifically, the new endpoint is constructed by concatenating the gateway root and the session identifier you've been returned (<code>e.g</code>., <code>/janus/12345678</code>).</p>
<p>This endpoint can be used in two different ways:</p>
<ol type="1">
<li>using a parameter-less <b>GET</b> request to the endpoint, you'll issue a long-poll request to be notified about events and incoming messages from this session;</li>
<li>using a <b>POST</b> request to send JSON messages, you'll interact with the session itself.</li>
</ol>
<hr/>
<dl class="section user"><dt>Long-poll requests</dt><dd>The long-poll will only trigger events related to messages you're being sent from plugins, and as such will be clearer to understand once you read the <a class="el" href="rest.html#handles">The plugin handle endpoint</a> section. That said, the events are formatted this way:</dd></dl>
<ul>
<li><code>janus:</code> this would be "event";</li>
<li><code>sender:</code> this would be the unique numeric plugin handle identifier;</li>
<li><code>transaction:</code> this is optional: it is either related to a request you sent to a plugin before, or it may be missing in case this is an event the plugin sent on its own account;</li>
<li><code>plugindata:</code> a JSON object containing the info coming from the plugin itself:<ul>
<li><code>plugin:</code> the plugin's unique package name (e.g., <code>janus.plugin.echotest</code>);</li>
<li><code>data:</code> an opaque JSON object that is plugin specific.</li>
</ul>
</li>
<li><code>jsep:</code> an optional JSON object containing the JSEP SDP (offer or answer) the plugin may send to negotiate a WebRTC PeerConnection with the client (check the <a class="el" href="rest.html#handles">The plugin handle endpoint</a> section for more details).</li>
</ul>
<p>An example of such an event (in this case, sent by the <a class="el" href="janus__echotest_8c.html" title="Janus EchoTest plugin.">janus_echotest.c</a> plugin in response to a request) is presented here:</p>
<pre class="fragment">{
        "janus" : "event",
        "sender" : 1815153248,
        "transaction" : "sBJNyUhH6Vc6",
        "plugindata" : {
                "plugin": "janus.plugin.echotest",
                "data" : {
                        "echotest" : "event",
                        "result" : "ok"
                }
        },
}
</pre><p>The long-poll request has a 30 seconds timeout. If it has no event to report, a simple <em>keep-alive</em> message will be triggered:</p>
<pre class="fragment">{
        "janus" : "keepalive",
}
</pre><p>As with all long-poll based approaches, it's up to your application to send a new polling request as soon as an event or a keep-alive has been received.</p>
<p>Notice that, by default, the long poll returns a single event: that is, as soon as a message becomes available in the session queue, that event is returned and the long poll closes. If you want to receive more events within the context of the same long poll, you can pass the <code>max_events</code> query string parameter to the GET, e.g.:</p>
<pre class="fragment">GET http://host:port/janus/&lt;sessionid&gt;?max_events=5
</pre><pre class="fragment">[
        {
                // Event #1
                "janus" : "event",
                [..]
        },
        {
                // Event #2
                "janus" : "event",
                [..]
        },
        [..]
]
</pre><p>This request will instruct the gateway to return at maximum 5 events within the context of the same long poll, formatted as a JSON array of events. Please beware that this does <b>NOT</b> mean that you'll always get 5 events this way: it only means that, if a message becomes available in the queue and more events are present as well, Janus will return more than one without needing you to send multiple long polls immediately thereafter to get them. For this reason, don't be surprised if even with a <code>max_events</code> parameter set, you'll still get a single event being notified as the sole object in the returned array.</p>
<hr/>
<dl class="section user"><dt>Interacting with the session</dt><dd>To interact with the session, e.g., to create a new handle to attach to a plugin or destroy the current session, you need to send a <b>POST</b> JSON message to the session endpoint.</dd></dl>
<p>To attach to a plugin in order to exploit its features, you need to <b>POST</b> a <code>janus</code> "attach" JSON message to the gateway; you'll need of course to provide information on the plugin you want to attach to, which can be done using the <code>plugin</code> field:</p>
<pre class="fragment">{
        "janus" : "attach",
        "plugin" : "&lt;the plugin's unique package name&gt;",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>If the request is successful, you'll receive the unique plugin handle identifier in a response formatted the same way as the session create one, that is like this:</p>
<pre class="fragment">{
        "janus" : "success",
        "transaction" : "&lt;same as the request&gt;"
        "data" : {
                "id" : &lt;unique integer plugin handle ID&gt;
        }
}
</pre><p>In case of an error, you'll receive an error message as the one introduced before. This request, if issued with a POST to a valid session endpoint, can only fail if you miss any of the required fields in the request or if the plugin you requested is not available in the gateway.</p>
<p>To destroy the current session, instead, just send a "destroy" <code>janus</code> request:</p>
<pre class="fragment">{
        "janus" : "destroy",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>This will also destroy the endpoint created for this session. If your session is currently managing one or more plugin handles, make sure you destroy them first (as explained in the next section). The gateway tries to do this automatically when receiving a session destroy request, but a cleaner approach on the client side would help nonetheless avoid potential issues.</p>
<h1><a class="anchor" id="handles"></a>
The plugin handle endpoint</h1>
<p>Once you've created a plugin handle, a new endpoint you can use is created in the gateway. Specifically, the new endpoint is constructed by concatenating the gateway root, the session identifier and the new plugin handle identifier you've been returned (<code>e.g</code>., <code>/janus/12345678/98765432</code>).</p>
<p>You can use this plugin handle for everything that is related to the communication with a plugin, that is, send the plugin a message, negotiate a WebRTC connection to attach to the plugin, and so on.</p>
<p>To send a plugin a message/request, you need to <b>POST</b> the handle endpoint a <code>janus</code> "message" JSON payload. The <code>body</code> field will have to contain a plugin-specific JSON payload. In case the message also needs to convey WebRTC-related negotiation information, a <code>jsep</code> field containing the JSON-ified version of the JSEP object can be attached as well.</p>
<dl class="section note"><dt>Note</dt><dd>If you attach a <code>jsep</code> object, whether it's an offer or an answer, you're stating your will to negotiate a PeerConnection. This means that an empty or invalid <code>jsep</code> object will trigger a validation and will cause the whole request to fail, so make sure you exclude the field completely from your request if all you're interested into is sending a message to a plugin.</dd></dl>
<p>Here's an example of a message you may send the <a class="el" href="janus__echotest_8c.html" title="Janus EchoTest plugin.">janus_echotest.c</a> plugin to mute your audio:</p>
<pre class="fragment">{
        "janus" : "message",
        "transaction" : "sBJNyUhH6Vc6",
        "body" : {
                "audio" : false
        }
}
</pre><p>The same message containing negotiation information as well, instead, (an OFFER, in this example), is presented here:</p>
<pre class="fragment">{
        "janus" : "message",
        "transaction" : "sBJNyUhH6Vc6",
        "body" : {
                "audio" : false
        },
        "jsep" : {
                "type" : "offer",
                "sdp" : "v=0\r\no=[..more sdp stuff..]"
        }
}
</pre><p>Considering the asynchronous nature of the Janus API, a successful management of such messages within the gateway will simply result in a <code>janus</code> "ack" messages being sent back to the client. A logical response to those messages, if needed, would be provided as an event in the long-poll interface described previously, and clients would be able to match it to the original request by means of the transaction identifiers. It is worth noting, though, that should a WebRTC negotiation be involved you don't have to expect an ANSWER to your OFFER to be sent back in the same transaction. A plugin may decide, in its application logic, to not provide you with an ANSWER right away, but only after some internal state changes occur. It's up to your application to handle the negotiation state accordingly.</p>
<p>An example of an "ack" being sent back to the client, using the previous sample request as a reference, is presented here:</p>
<pre class="fragment">{
        "janus" : "ack",
        "transaction" : "sBJNyUhH6Vc6"
}
</pre><p>If you receive this ack, you can be sure the plugin has received the message, and is going to process it soon.</p>
<p>In case of an error, instead, you'll receive an error message as the one introduced before. This request, if issued with a POST to a valid plugin handle endpoint, can only fail if you miss any of the required fields in the request, if the plugin you tried to contact is not available in the gateway anymore, if an error occurred in the plugin when trying to receive the message or if the <code>jsep</code> SDP you may have provided is invalid.</p>
<p>To destroy the plugin handle, instead, just send a "detach" <code>janus</code> request:</p>
<pre class="fragment">{
        "janus" : "detach",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>This will also destroy the endpoint created for this plugin handle. If your plugin handle is also managing an ongoing WebRTC connection with the plugin, make sure it is torn down as part of this process. The plugin implementation and the gateway core should do this automatically, but implementing the right behaviour in clients would help avoid potential issues nonetheless.</p>
<h1><a class="anchor" id="secret"></a>
Securing the API</h1>
<p>Several deployers showed an interested in wrapping the Janus API on their server side: this allows them to keep the interaction with their users the way it was before, while still benefiting from the features Janus provides. This is an easy enough step, as it just needs developers to relay the involved SDP, and implementing the Janus API messages to handle the logic.</p>
<p>That said, since in this case Janus would be contacted, through the API, just by a limited number of applications (e.g., application servers made in node.js, Ruby, Java Servlets or whatever) and not random browsers, it is reasonable to involve a mechanism to control who is allowed to contact and control it. To allow for that, Janus exposes a shared API secret mechanism: that is, you configure Janus with a string applications need to present when sending requests, and if they don't, Janus rejects them with an <code>unauthorized</code> message.</p>
<p>Configuring the API secret mechanism is easy enough: you can do that either via the command line (<code>-a</code> or <code>&ndash;apisecret</code> ) or in the <code>janus.cfg</code> configuration (<code>apisecret</code> value in the <code>general</code> section). When enabled, all requests addressed to that Janus instance <b>MUST</b> also contain an <code>apisecret</code> field in the Janus message headers. For instance, this message presented above would fail:</p>
<pre class="fragment">{
        "janus" : "create",
        "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><pre class="fragment">{
        "janus": "error",
        "error": {
                "reason": "Unauthorized request (wrong or missing apisecret)",
                "code": 403
        }
}
</pre><p>For a successful transaction, the message would have to look like this:</p>
<pre class="fragment">{
        "janus" : "create",
        "apisecret" : "&lt;API secret configured in Janus&gt;",
        "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><p>The same applies for the long poll GET messages as well, which will need to contain the <code>apisecret</code> as a query string parameter.</p>
<h1><a class="anchor" id="WS"></a>
WebSockets Interface</h1>
<p>In recent version of Janus we added support for WebSockets to control the gateway, along the already existing (and still the default) REST API. In fact, while WebSockets still present some more issues in terms of reachability when compared to plain HTTP, they definitely provide a more efficient means for implementing a bidirectional communication. This is especially useful if you're wrapping the Janus API on your servers, as it allows you to avoid all the noise and overhead introduced by several concurrent HTTP transactions and long polls by relying on what may be seen as a single "control channel".</p>
<p>As anticipated at the beginning of this section, the actual messages being exchanged are exactly the same. This means that all the concepts introduced before still apply: you still create a session, attach to a plugin and interact with it exactly the same way. What is different is, of course, the REST path approach that becomes unavailable when using a WebSocket as a control channel. To address the idenfitiers that become missing using WebSockets, you'll need to add additional fields to the requests when necessary.</p>
<p>So, when you want to create a session using the REST API, you send a POST to the gateway base path:</p>
<pre class="fragment">{
        "janus" : "create",
        "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><p>The same applies if you're interested in getting generic info from the Janus instance. Since there's no <b>GET</b> you can use, a specific <code>janus</code> request type called <code>info</code> is available:</p>
<pre class="fragment">{
        "janus" : "info",
        "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><p>Since you'd contact the base path for both requests, you don't need to add any identifier for this scenario. But if instead you want to attach to a plugin within the context of a specific session, using the REST API you'd send a post to the <code>/janus/&lt;session-id&gt;</code> endpoint:</p>
<pre class="fragment">{
        "janus" : "attach",
        "plugin" : "&lt;the plugin's unique package name&gt;",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>To make this work with WebSockets as well, you need to add a further field called <code>session_id</code> in the request:</p>
<pre class="fragment">{
        "janus" : "attach",
        "session_id" : "&lt;the session identifier&gt;",              // NEW!
        "plugin" : "&lt;the plugin's unique package name&gt;",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>which will allow the WebSocket server to understand which session this request pertains to. At the same time, when you need to address a specific handle (e.g., to send a message to a plugin, or negotiate a WebRTC PeerConnection) you'll need to add a <code>handle_id</code> field to the request as well, or the request will be rejected:</p>
<pre class="fragment">{
        "janus" : "message",
        "session_id" : "&lt;the session identifier&gt;",              // NEW!
        "handle_id" : "&lt;the handle identifier&gt;",                // NEW!
        "transaction" : "sBJNyUhH6Vc6",
        "body" : {
                "audio" : false
        }
}
</pre><p>Considering the bidirectional nature of WebSockets and the fact that the channel will be shared for different requests, you'll need to pay extra attention to the <code>transaction</code> identifier, which will allow you to map incoming responses and events to the request you sent that originated them.</p>
<p>An <b>important</b> aspect to point out is related to keep-alive messages for WebSockets Janus channels. A Janus session is kept alive as long as there's no inactivity for 60 seconds: if no messages have been received in that time frame, the session is torn down by the gateway. A normal activity on a session is usually enough to prevent that; for a more prolonged inactivity with respect to messaging, on plain HTTP the session is usually kept alive through the regular long poll requests, which act as activity as long as the session is concerned. This aid is obviously not possible when using WebSockets, where a single channel is used both for sending requests and receiving events and responses. For this reason, an ad-hoc message for keeping alive a Janus session should to be triggered on a regular basis:</p>
<pre class="fragment">{
        "janus" : "keepalive",
        "session_id" : "&lt;the session identifier&gt;",
        "transaction" : "sBJNyUhH6Vc6"
}
</pre><p>This will make sure that the gateway detects activity on the session even when no actual messages are being exchanged with handles.</p>
<p>As a last point, another slight difference with WebSockets comes from how push notifications are implemented. In the <a class="el" href="rest.html#plainhttp">Plain HTTP REST Interface</a> this is done via long polls: that is, you explicitly subscribe to notifications, and have to do that again as soon as an event has been received. With WebSockets, this is not needed: as soon as you create a session on a WebSocket, that channel becomes automatically subscribed for events related to that sessions, and you'll receive them on the same WebSocket. For the same reason, as soon as the WebSocket is closed, all the sessions created within its context are considered closed as well, and so their resources (including all the handles and PeerConnections) will be released as well.</p>
<dl class="section note"><dt>Note</dt><dd>The same <code>janus.js</code> JavaScript library can be used both with the REST and the WebSockets API: all you need to do is provide the right Janus server address during the initialization and the library will use one or the other according to the protocol prefix. </dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Janus WebRTC Gateway &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014
</div>
</body>

<!-- Mirrored from janus.conf.meetecho.com/docs/rest.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 25 Jul 2014 16:30:37 GMT -->
</html>
