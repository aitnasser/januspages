<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from janus.conf.meetecho.com/docs/JS.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 25 Jul 2014 16:30:37 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>JavaScript API</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="css/bootstrap.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 1001;" src="../../s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<nav class="navbar navbar-default navbar-static-top">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href=".html">Janus</a>
		<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
	</div>
	<div class="navbar-collapse collapse">
		<ul class="nav navbar-nav">
			<li><a href="../index-2.html">Home</a></li>
			<li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Demos <b class="caret"></b></a>
				<ul class="dropdown-menu">
					<li><a href="../demos.html">Index</a></li>
					<li class="divider"></li>
					<li><a href="../echotest.html">Echo Test</a></li>
					<li><a href="../streamingtest.html">Streaming</a></li>
					<li><a href="../videocalltest.html">Video Call</a></li>
					<li><a href="../siptest.html">SIP Gateway</a></li>
					<li><a href="../videomcutest.html">Video MCU</a></li>
					<li><a href="../audiobridgetest.html">Audio Conference</a></li>
					<li><a href="../voicemailtest.html">Voice Mail</a></li>
					<li><a href="../screensharingtest.html">Screen Sharing</a></li>
				</ul>
			</li>
			<li class="active"><a href="index-2.html">Documentation</a></li>
		</ul>
		<div class="navbar-header navbar-right">
			<ul id="topmenu" class="nav navbar-nav">
<!--
				<li>
					<form class="navbar-form navbar-left" role="search">
						<div class="form-group">
							<input type="text" class="form-control" placeholder="Search"/>
						</div>
					</form>
				</li>
-->
				<li><a href="http://groups.google.com/d/forum/meetecho-janus" class="navbar-link"><b>Discuss Janus</b></a></li>
				<li><a href="http://www.meetecho.com/" class="navbar-link"><img src="meetecho-logo-white.png"/> <b>Meetecho</b></a></li>
			</ul>
		</div>
	</div>
</div>
</nav>
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index-2.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">JavaScript API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The gateway exposes both a pseudo-RESTful interface, and optionally a WebSocket interface as well, both of which based on JSON messages. These interfaces are described in more detail in the <a class="el" href="rest.html#plainhttp">Plain HTTP REST Interface</a> and <a class="el" href="rest.html#WS">WebSockets Interface</a> documentation respectively, and both allow web applications to take advantage of the features provided by Janus and the functionality made available by its plugins. To make things easier for web developers, a JavaScript library (<code>janus.js</code>) is available that can make use of both interfaces using exactly the same API. This library eases the task of creating sessions with the gateway, attaching WebRTC users to plugins, send and receive requests and events to the plugins themselves and so on. For real examples of how this library can be used, check the demos in the <b>html</b> folder of this package.</p>
<dl class="section note"><dt>Note</dt><dd>The current <code>janus.js</code> library makes use of jQuery (<a href="http://jquery.com/">http://jquery.com/</a>) as a support. We're considering preparing versions that make use of different libraries as well (e.g., Prototype, Dojo, Script.aculo.us, etc.) in case your web application us based on something that cannot make use of jQuery. Of course, if you happen to prepare one yourself in the meanwhile don't hesitate and let us know! :-)</dd></dl>
<p>In general, when using the gateway features, you would normally do the following:</p>
<ol type="1">
<li>include the Janus JavaScript library in your web page;</li>
<li>initialize the Janus JavaScript library;</li>
<li>connect to the gateway and create a session;</li>
<li>create one or more handles to attach to a plugin (e.g., echo test and/or streaming);</li>
<li>interact with the plugin (sending/receiving messages, negotiating a PeerConnection);</li>
<li>eventually, close all the handles and shutdown the related PeerConnections;</li>
<li>destroy the session.</li>
</ol>
<p>The above steps will be presented in order, describing how you can use the low level API to accomplish them. Consider that in the future we might provide higher level wrappers to this API to address specific needs, e.g., a higher level API for each plugin: this would make it even easier to use the gateway features, as a high level API for the streaming plugin, for instance, may just ask you to provide the server address and the ID of the <code>&lt;video&gt;</code> element to display the stream in, and would take care of all the above mentioned steps on your behalf. Needless to say, you're very welcome to provide wrapper APIs yourself, if you feel a sudden urge to do so! :-)</p>
<hr/>
<p>As a first step, you should include the <code>janus.js</code> library in your project:</p>
<pre class="fragment">&lt;script type="text/javascript" src="janus.js" &gt;&lt;/script&gt;
</pre><p>The core of the JavaScript API is the <code>Janus</code> object. This object needs to be initialized the first time it is used in a page. This can be done using the static <code>init</code> method of the object, which accepts the following options:</p>
<ul>
<li><code>debug:</code> whether debug should be enabled on the JavaScript console (true/false, default=false)</li>
<li><code>callback:</code> a user provided function that is invoked when the initialization is complete.</li>
</ul>
<p>Here's an example:</p>
<pre class="fragment">Janus.init({
   debug: true,
   callback: function() {
           // Done!
   });</pre><p>Once the library has been initialized, you can start creating sessions. Normally, each browser tab will need a single session with the gateway: in fact, each gateway session can contain several different plugin handles at the same time, meaning you can start several different WebRTC sessions with the same or different plugins for the same user using the same gateway session. That said, you're free to set up different gateway sessions in the same page, should you prefer so.</p>
<p>Creating a session is quite easy. You just need to use the <code>new</code> constructor to create a new <code>Janus</code> object that will handle your interaction with the gateway. Considering the dynamic and asynchronous nature of Janus sessions (events may occur at any time), there are several properties and callbacks you can configure when creating a session:</p>
<ul>
<li><code>server:</code> the address of the gateway as a specific address (e.g., <a href="http://yourserver:8088/janus">http://yourserver:8088/janus</a> to use the plain HTTP API or ws://yourserver:8188/ for WebSockets) or as an array of addresses to try sequentially to allow automatic for fallback/failover during setup;</li>
<li><code>iceServers:</code> a list of STUN/TURN servers to use (a default STUN server will be used if you skip this property);</li>
<li>a set of callbacks to be notified about events, namely:<ul>
<li><code>success:</code> the session was successfully created and is ready to be used;</li>
<li><code>error:</code> the session was NOT successfully created;</li>
<li><code>destroyed:</code> the session was destroyed and can't be used any more.</li>
</ul>
</li>
</ul>
<p>These properties and callbacks are passed to the method as properties of a single parameter object: that is, the <code>Janus</code> constructor takes a single parameter, which although acts as a container for all the available options. The <code>success</code> callback is where you tipically start your application logic, e.g., attaching the peer to a plugin and start a media session.</p>
<p>Here's an example:</p>
<pre class="fragment">var janus = new Janus(
        {
                server: 'http://yourserver:8088/janus',
                success: function() {
                        // Done! attach to plugin XYZ
                },
                error: function(cause) {
                        // Error, can't go on...
                },
                destroyed: function() {
                        // I should get rid of this
                }
        });</pre><p>As anticipated, the server may be a specific address, e.g.:</p>
<pre class="fragment">var janus = new Janus(
        {
                server: 'http://yourserver:8088/janus',
                                // or
                server: 'ws://yourserver:8188/',
                [..]</pre><p>or an array of addresses. Such an array can be especially useful if you want the library to first check if the WebSockets server is reachable and, if not, fallback to plain HTTP, or just to provide a link multiple instances to try for failover. This is an example of how to pass a 'try websockets and fallback to HTTP' array:</p>
<pre class="fragment">var janus = new Janus(
        {
                server: ['ws://yourserver:8188/','http://yourserver:8088/janus'],
                [..]</pre><p>Once created, this object represents your session with the gateway. you can interact with a <code>Janus</code> object in several different ways. In particular, the following properties and methods are defined:</p>
<ul>
<li><code>getServer()</code>: returns the address of the gateway;</li>
<li><code>isConnected()</code>: returns <code>true</code> if the Janus instance is connected to the gateway, <code>false</code> otherwise;</li>
<li><code>getSessionId()</code>: returns the unique gateway session identifier;</li>
<li><code>attach(parameters)</code>: attaches the session to a plugin, creating an handle; more handles to the same or different plugins can be created at the same time;</li>
<li><code>destroy(parameters)</code>: destroys the session with the gateway, and closes all the handles (and related PeerConnections) the session may have with any plugin as well.</li>
</ul>
<p>The most important property is obviously the <code>attach()</code> method, as it's what will allow you to exploit the features of a plugin to manipulate the media sent and/or received by a PeerConnection in your web page. This method will create a plugin handle you can use for the purpose, for which you can configure properties and callbacks when calling the <code>attach()</code> method itself. As for the <code>Janus</code> constructor, the <code>attach()</code> method takes a single parameter that can contain any of the following properties and callbacks:</p>
<ul>
<li><code>plugin:</code> the unique package name of the plugin (e.g., <code>janus.plugin.echotest</code> ); will be used if you skip this property)</li>
<li>a set of callbacks to be notified about events, namely:<ul>
<li><code>success:</code> the handle was successfully created and is ready to be used;</li>
<li><code>error:</code> the handle was NOT successfully created;</li>
<li><code>consentDialog:</code> this callback is triggered just before <code>getUserMedia</code> is called (parameter=<b>true</b>) and after it is completed (parameter=<b>false</b>); this means it can be used to modify the UI accordingly, e.g., to prompt the user about the need to accept the device access consent requests;</li>
<li><code>onmessage:</code> a message/event has been received from the plugin;</li>
<li><code>onlocalstream:</code> a local <code>MediaStream</code> is available and ready to be displayed;</li>
<li><code>onremotestream:</code> a remote <code>MediaStream</code> is available and ready to be displayed;</li>
<li><code>ondataopen:</code> a Data Channel is available and ready to be used;</li>
<li><code>ondata:</code> data has been received through the Data Channel;</li>
<li><code>oncleanup:</code> the WebRTC PeerConnection with the plugin was closed;</li>
<li><code>detached:</code> the plugin handle has been detached by the plugin itself, and so should not be used anymore.</li>
</ul>
</li>
</ul>
<p>Here's an example:</p>
<pre class="fragment">// Attach to echo test plugin, using the previously created janus instance
janus.attach(
        {
                plugin: "janus.plugin.echotest",
                success: function(pluginHandle) {
                        // Plugin attached! 'pluginHandle' is our handle
                },
                error: function(cause) {
                        // Couldn't attach to the plugin
                },
                consentDialog: function(on) {
                        // e.g., Darken the screen if on=true (getUserMedia incoming), restore it otherwise
                },
                onmessage: function(msg, jsep) {
                        // We got a message/event (msg) from the plugin
                        // If jsep is not null, this involves a WebRTC negotiation
                },
                onlocalstream: function(stream) {
                        // We have a local stream (getUserMedia worked!) to display
                },
                onremotestream: function(stream) {
                        // We have a remote stream (working PeerConnection!) to display
                },
                oncleanup: function() {
                        // PeerConnection with the plugin closed, clean the UI
                        // The plugin handle is still valid so we can create a new one
                },
                detached: function() {
                        // Connection with the plugin closed, get rid of its features
                        // The plugin handle is not valid anymore
                }
        });</pre><p>So the <code>attach()</code> method allows you to attach to a plugin, and specify the callbacks to invoke when anything relevant happens in this interaction. To actively interact with the plugin, you can use the <code>Handle</code> object that is returned by the <code>success</code> callback (pluginHandle in the example).</p>
<p>This <code>Handle</code> object has several methods you can use to interact with the plugin or check the state of the session handle:</p>
<ul>
<li><code>getId()</code>: returns the unique handle identifier;</li>
<li><code>getPlugin()</code>: returns the unique package name of the attached plugin;</li>
<li><code>send(parameters)</code>: sends a message (with or without a jsep to negotiate a PeerConnection) to the plugin;</li>
<li><code>createOffer(callbacks)</code>: asks the library to create a WebRTC compliant OFFER;</li>
<li><code>createAnswer(callbacks)</code>: asks the library to create a WebRTC compliant ANSWER;</li>
<li><code>handleRemoteJsep(callbacks)</code>: asks the library to handle an incoming WebRTC compliant session description;</li>
<li><code>dtmf(parameters)</code>: sends a DTMF tone on the PeerConnection;</li>
<li><code>data(parameters)</code>: sends data through the Data Channel, if available;</li>
<li><code>getBitrate()</code>: gets a verbose description of the currently received stream bitrate (only available on Chrome, for now);</li>
<li><code>hangup()</code>: tells the library to close the PeerConnection;</li>
<li><code>detach(parameters)</code>: detaches from the plugin and destroys the handle, tearing down the related PeerConnection if it exists.</li>
</ul>
<p>While the <code>Handle</code> API may look complex, it's actually quite straightforward once you get the concept. The only step that may require a little more effort to understand is the PeerConnection negotiation, but again, if you're familiar with the WebRTC API, the <code>Handle</code> actually makes it a lot easier.</p>
<p>The idea behind it's usage is the following:</p>
<ol type="1">
<li>you use <code>attach()</code> to create a <code>Handle</code> object;</li>
<li>in the <code>success</code> callback, your application logic can kick in: you may want to send a message to the plugin ( <code>send(msg)</code> ), negotiate a PeerConnection with the plugin right away ( <code>createOffer</code> followed by a <code>send(msg, jsep)</code> ) or wait for something to happen to do anything;</li>
<li>the <code>onmessage</code> callback tells you when you've got messages from the plugin; if the <code>jsep</code> parameter is not null, just pass it to the library, which will take care of it for you; if it's an <b>OFFER</b> use <code>createAnswer</code> (followed by a <code>send(msg, jsep)</code> to close the loop with the plugin), otherwise use <code>handleRemoteJsep</code> ;</li>
<li>whether you took the initiative to set up a PeerConnection or the plugin did, the <code>onlocalstream</code> and/or the <code>onremotestream</code> callbacks will provide you with a stream you can display in your page;</li>
<li>each plugin may allow you to manipulate what should flow through the PeerConnection channel: the <code>send</code> method and <code>onmessage</code> callback will allow you to handle this interaction (e.g., to tell the plugin to mute your stream, or to be notified about someone joining a virtual room), while the <code>ondata</code> callback is triggered whenever data is received on the Data Channel, if available (and the <code>ondataopen</code> callback will tell you when a Data Channel is actually available).</li>
</ol>
<p>The following paragraphs will delve a bit deeper in the negotiation mechanism provided by the <code>Handle</code> API, in particular describing the properties and callbacks that may be involved. To follow the approach outlined by the W3C WebRTC API, this negotiation mechanism is heavily based on asynchronous methods as well.</p>
<ul>
<li><code>createOffer</code> takes a single parameter, that can contain any of the following properties and callbacks:<ul>
<li><code>media:</code> you can use this property to tell the library which media (audio/video/data) you're interested in, and whether you're going to send and/or receive any of them; by default audio and video are enabled in both directions, while the Data Channels are disabled; this option is an object that can take any of the following properties:<ul>
<li><code>audioSend:</code> <code>true/false</code> (do or do not send audio);</li>
<li><code>audioRecv:</code> <code>true/false</code> (do or do not receive audio);</li>
<li><code>audio:</code> <code>true/false</code> (do or do not send <b>and</b> receive audio, takes precedence on the above);</li>
<li><code>videoSend:</code> <code>true/false</code> (do or do not send video);</li>
<li><code>videoRecv:</code> <code>true/false</code> (do or do not receive video);</li>
<li><code>video:</code> <code>true/false</code> (do or do not send <b>and</b> receive video, takes precedence on the above);</li>
<li><code>video:</code> <code>"hires"/"lowres"</code> (send a 1280x720 or a 320x240 video, takes precedence on the above); this property will affect the resulting getUserMedia that the library will issue;</li>
<li><code>video:</code> <code>"screen"</code> (use screensharing for video, disables audio, takes precedence on both audio and video);</li>
<li><code>data:</code> <code>true/false</code> (do or do not use Data Channels, default is false)</li>
</ul>
</li>
<li><code>trickle:</code> <code>true/false</code>, to tell the library whether you want Trickle ICE to be used (true, the default) or not (false);</li>
<li>a set of callbacks to be notified about the result, namely:<ul>
<li><code>success:</code> the session description was created (attached as a parameter) and is ready to be sent to the plugin;</li>
<li><code>error:</code> the session description was NOT successfully created;</li>
</ul>
</li>
</ul>
</li>
<li><code>createAnswer</code> takes the same options as createOffer, but requires an additional one as part of the single parameter argument:<ul>
<li><code>jsep:</code> the session description sent by the plugin (e.g., as received in an <code>onmessage</code> callback) as its OFFER.</li>
</ul>
</li>
</ul>
<p>Whether you use <code>createOffer</code> or <code>createAnswer</code> depending on the scenario, you should end up with a valid <code>jsep</code> object returned in the <code>success</code> callback. You can attach this <code>jsep</code> object to a message in a <code>send</code> request to pass it to the plugin, and have the gateway negotiate a PeerConnection with your application.</p>
<p>Here's an example of how to use <code>createOffer</code>, taken from the Echo Test demo page:</p>
<pre class="fragment">// Attach to echo test plugin
janus.attach(
        {
                plugin: "janus.plugin.echotest",
                success: function(pluginHandle) {
                        // Negotiate WebRTC
                        echotest = pluginHandle;
                        var body = { "audio": true, "video": true };
                        echotest.send({"message": body});
                        echotest.createOffer(
                                {
                                        // No media property provided: by default,
                                                // it's sendrecv for audio and video
                                        success: function(jsep) {
                                                // Got our SDP! Send our OFFER to the plugin
                                                echotest.send({"message": body, "jsep": jsep});
                                        },
                                        error: function(error) {
                                                // An error occurred...
                                        }
                                });
                },
                [..]
                onmessage: function(msg, jsep) {
                        // Handle msg, if needed, and check jsep
                        if(jsep !== undefined &amp;&amp; jsep !== null) {
                                // We have the ANSWER from the plugin
                                echotest.handleRemoteJsep({jsep: jsep});
                        }
                },
                [..]
                onlocalstream: function(stream) {
                        // Invoked after createOffer
                        // This is our video
                },
                onremotestream: function(stream) {
                        // Invoked after handleRemoteJsep has got us a PeerConnection
                        // This is the remote video
                },
                [..]</pre><p>This, instead, is an example of how to use <code>createAnswer</code>, taken from the Streaming demo page:</p>
<pre class="fragment">// Attach to echo test plugin
janus.attach(
        {
                plugin: "janus.plugin.streaming",
                success: function(pluginHandle) {
                        // Handle created
                        streaming = pluginHandle;
                        [..]
                },
                [..]
                onmessage: function(msg, jsep) {
                        // Handle msg, if needed, and check jsep
                        if(jsep !== undefined &amp;&amp; jsep !== null) {
                                // We have an OFFER from the plugin
                                streaming.createAnswer(
                                        {
                                                // We attach the remote OFFER
                                                jsep: jsep,
                                                // We want recvonly audio/video
                                                media: { audioSend: false, videoSend: false },
                                                success: function(ourjsep) {
                                                        // Got our SDP! Send our ANSWER to the plugin
                                                        var body = { "request": "start" };
                                                        streaming.send({"message": body, "jsep": ourjsep});
                                                },
                                                error: function(error) {
                                                        // An error occurred...
                                                }
                                        });
                        }
                },
                [..]
                onlocalstream: function(stream) {
                        // This will NOT be invoked, we chose recvonly
                },
                onremotestream: function(stream) {
                        // Invoked after send has got us a PeerConnection
                        // This is the remote video
                },
                [..]</pre><p>Of course, these are just a couple of examples where the scenarios assumed that one plugin would only receive (Echo Test) or generate (Streaming) offers. A more complex example (e.g., a Video Call plugin) would involve both, allowing you to either send offers to a plugin, or receive some from them. Handling this is just a matter of checking the <code>type</code> of the <code>jsep</code> object and reacting accordingly.</p>
<hr/>
<p>This is it! For more information about the API, have a look at the demo pages that are available in the <b>html</b> folder in this package. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Janus WebRTC Gateway &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014
</div>
</body>

<!-- Mirrored from janus.conf.meetecho.com/docs/JS.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 25 Jul 2014 16:30:37 GMT -->
</html>
